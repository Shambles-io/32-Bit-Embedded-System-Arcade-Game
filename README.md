# Embedded-System-Arcade-Game
Project Summary:
  This project challenged us to design and create our own embedded system arcade game. From the hardware side, one needs a breadboard, LCD screen, joystick, numerous wires and jumper cables, and the MSP432 Microcontroller. We use the energia software so write the code for the system. Following the project milestones leads us to create a game that allows the user to control a character - the Hero. By incorporating embedded system concepts, such as state machines, interrupt handling, analog-to-digital conversion, and knowledge learned from the semester.

System Functionality and Circuit Design:
  To play, the player uses the joystick to control the hero’s forward and backward movements, the joystick can also be pressed to make the hero jump. These movements are visible on the LCD screen. The joystick and LCD are connected through the microcontroller. The joystick is connected to 5 V and Ground; using the microcontroller’s data sheet (shown above) we connect a terminal that preforms an analogRead operation to the joystick’s 𝑋𝑜𝑢𝑡 pin. We need the analogRead because 𝑋𝑜𝑢𝑡 is a range of values from 0 to (approx.) 1000, and the value being read dictates whether the hero is moving forward or backward. By measuring the resting value of the joystick, one may determine the left and right thresholds such that moving the stick past a point to the left or right will register as moving the hero in that respective direction. We must also connect a terminal capable of digitalRead, digitalWrite, and analogWrite from the microcontroller to the Sw pin on the joystick. This allows the microcontroller to read the pressing of the joystick, which is expressed as a 0 or 1. Jumping also causes one of the interrupt service routines (ISR), which is beneficial for testing in the beginning of the project. The JumpISR is also needed to keep our hero in the air for two (2) counts when they jump. The LCD screen is connected using the diagram shown below, which was provided by the project milestones. The games base functionality is to have the user control the hero, and have the hero jump over a wall (obstacle) that moves across the screen. If the hero collides with the obstacle, the game will end. However, we were encouraged to experiment and try to add more to the game, which will be addressed further.

![image](https://user-images.githubusercontent.com/92652583/166788065-54438086-4f1b-4bc0-b902-f65d758804e0.png)
![image](https://user-images.githubusercontent.com/92652583/166786820-03137dd2-b88d-4e12-8fc2-cbdd8b8c15d3.png)
![image](https://user-images.githubusercontent.com/92652583/166785555-7eaaf93f-2760-4bd1-bada-0b4b9b623115.png)
![image](https://user-images.githubusercontent.com/92652583/166784393-a76a05b3-ffb5-43ab-aee4-d78c510c1ac1.png)
![image](https://user-images.githubusercontent.com/92652583/166782902-c7079101-0829-432d-adfc-d0bef1944092.png)

Embedded Control Design:
![image](https://user-images.githubusercontent.com/92652583/166781535-853196a4-402a-4476-8768-32a42cd2469f.png)

  The game runs by the two state machines running simultaneously in the figures above. The figure labeled PlayerActions is the state machine of our hero. The bubbles are the hero’s different state and the arrows are the transition conditions that causes one state to go to another for the hero. For example, if the joystick is read past the forward threshold, it will raise the forwardFlag-doing this would move the hero forward one position. During the jump action, there is a count condition; the count is to ensure the hero is in the air long enough some out obstacle to pass under him-without the count, the hero would rise and immediately fall, without anything being able to pass under.

Enhancements:
  Enhancements made to the original game logic were all done by coding. The first change and upgrades were made to the hero shape. By understanding how the 0’s and 1’s in the byte struct create the physical hero shape, one may create their own hero. I decided to make a skateboarder, and when jumping writes a different hero shape that shows the board flipping. The obstacle shape was also changed. The final enhancement was a “level” count. Initially I wanted to incorporate levels, such that every two obstacles that were jumped advances the player a level, and each level increases the speed of the incoming obstacle. However, the code logic to increase obstacle speed was not finished. Instead, the level count was included, so when the game ends, it displays the user’s high score
